"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsDoc = exports.indent = exports.inline = exports.writeDocumentPartsToString = exports.writeDocumentPartsToStream = exports.NewLine = exports.InlineMode = exports.PropertyDelimiter = exports.RestoreLineMode = exports.NewLineMode = exports.DecIndentAndCloseBlock = exports.DecIndent = exports.IncIndent = void 0;
exports.IncIndent = Symbol('Increase Indent');
exports.DecIndent = Symbol('Decrease Indent');
exports.DecIndentAndCloseBlock = Symbol('Decrease Indent and write a closing brace');
exports.NewLineMode = Symbol('New Line Mode');
exports.RestoreLineMode = Symbol('Restore Line Mode');
exports.PropertyDelimiter = Symbol('Property Delimiter');
exports.InlineMode = Symbol('Inline Mode');
exports.NewLine = Symbol('New Line');
function writeDocumentPartsToStream(document, stream, options = {}) {
    const writer = {
        _last: '',
        write(val) {
            this._last = val;
            stream.write(val);
        },
        get last() {
            return this._last;
        },
    };
    writeDocumentPartsTo(document, options, writer);
}
exports.writeDocumentPartsToStream = writeDocumentPartsToStream;
function writeDocumentPartsToString(document, options = {}) {
    const writer = {
        result: [],
        _last: '',
        write(val) {
            this._last = val;
            this.result.push(val);
        },
        get last() {
            return this._last;
        },
        toString() {
            return this.result.join('');
        },
    };
    writeDocumentPartsTo(document, options, writer);
    return writer.toString();
}
exports.writeDocumentPartsToString = writeDocumentPartsToString;
function* inline(...parts) {
    yield exports.InlineMode;
    for (const part of parts) {
        if (typeof part === 'string' || typeof part === 'symbol')
            yield part;
        else
            yield* part;
    }
    yield exports.RestoreLineMode;
}
exports.inline = inline;
function* indent(...parts) {
    yield exports.IncIndent;
    for (const part of parts) {
        if (typeof part === 'string' || typeof part === 'symbol')
            yield part;
        else
            yield* part;
    }
    yield exports.DecIndent;
}
exports.indent = indent;
function* jsDoc(docs) {
    var _a;
    yield `/**`;
    if (typeof docs === 'string') {
        yield ` * ${docs}`;
    }
    else {
        yield ` * ${docs.description}`;
        if (docs.abiDescription) {
            yield ' *';
            yield ` * ${docs.abiDescription}`;
        }
        if (docs.params || docs.returns) {
            yield ' *';
        }
        for (const [paramName, paramDesc] of Object.entries((_a = docs.params) !== null && _a !== void 0 ? _a : {})) {
            yield ` * @param ${paramName} ${paramDesc}`;
        }
        if (docs.returns)
            yield ` * @returns ${docs.returns}`;
    }
    yield ' */';
}
exports.jsDoc = jsDoc;
function writeDocumentPartsTo(document, { indent = '  ', ...options }, writer) {
    if (options.header)
        writer.write(`${options.header}\n`);
    if (options.disableEslint)
        writer.write('/* eslint-disable */\n');
    const lineModes = [exports.NewLineMode];
    const currentLineMode = () => { var _a; return (_a = lineModes.at(-1)) !== null && _a !== void 0 ? _a : exports.NewLineMode; };
    let curIndent = '';
    for (const part of document) {
        switch (part) {
            case exports.IncIndent:
                curIndent += indent;
                break;
            case exports.DecIndent:
                curIndent = curIndent.slice(0, -indent.length);
                break;
            case exports.DecIndentAndCloseBlock:
                curIndent = curIndent.slice(0, -indent.length);
                writer.write(`${curIndent}}\n`);
                break;
            case exports.NewLineMode:
                lineModes.push(exports.NewLineMode);
                if (writer.last.slice(-1)[0] !== '\n') {
                    writer.write('\n');
                }
                break;
            case exports.InlineMode:
                lineModes.push(exports.InlineMode);
                break;
            case exports.RestoreLineMode:
                lineModes.pop();
                if (currentLineMode() === exports.NewLineMode && writer.last.slice(-1)[0] !== '\n') {
                    writer.write('\n');
                }
                break;
            case exports.PropertyDelimiter:
                if (currentLineMode() === exports.NewLineMode) {
                    writer.write('\n');
                }
                else {
                    writer.write(', ');
                }
                break;
            case exports.NewLine:
                writer.write('\n');
                break;
            default:
                if (writer.last.slice(-1)[0] === '\n')
                    writer.write(curIndent);
                writer.write(part);
                if (currentLineMode() === exports.NewLineMode)
                    writer.write('\n');
                break;
        }
    }
}
//# sourceMappingURL=writer.js.map