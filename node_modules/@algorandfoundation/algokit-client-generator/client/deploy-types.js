"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployTypes = exports.getCreateOnCompleteOptions = void 0;
const writer_1 = require("../output/writer");
const sanitization_1 = require("../util/sanitization");
const get_call_config_summary_1 = require("./helpers/get-call-config-summary");
const utility_types_1 = require("./utility-types");
function getCreateOnCompleteOptions(method, app) {
    var _a, _b;
    const callConfig = method === get_call_config_summary_1.BARE_CALL ? app.bare_call_config : (_b = (_a = app.hints) === null || _a === void 0 ? void 0 : _a[method]) === null || _b === void 0 ? void 0 : _b.call_config;
    const hasNoOp = (callConfig === null || callConfig === void 0 ? void 0 : callConfig.no_op) === 'ALL' || (callConfig === null || callConfig === void 0 ? void 0 : callConfig.no_op) === 'CREATE';
    const onCompleteType = callConfig
        ? `(${Object.entries(callConfig)
            .filter(([_, value]) => value === 'ALL' || value === 'CREATE')
            .map(([oc]) => utility_types_1.OnCompleteCodeMap[oc])
            .join(' | ')})`
        : {};
    return {
        type: onCompleteType,
        isOptional: hasNoOp,
    };
}
exports.getCreateOnCompleteOptions = getCreateOnCompleteOptions;
function* deployTypes({ app, callConfig }) {
    const name = (0, sanitization_1.makeSafeTypeIdentifier)(app.contract.name);
    if (callConfig.createMethods.length > 0) {
        yield* (0, writer_1.jsDoc)(`A factory for available 'create' calls`);
        yield `export type ${name}CreateCalls = (typeof ${name}CallFactory)['create']`;
        yield* (0, writer_1.jsDoc)('Defines supported create methods for this smart contract');
        yield `export type ${name}CreateCallParams =`;
        yield writer_1.IncIndent;
        for (const method of callConfig.createMethods) {
            const onComplete = getCreateOnCompleteOptions(method, app);
            if (method === get_call_config_summary_1.BARE_CALL) {
                yield `| (TypedCallParams<undefined> & ${onComplete.type})`;
            }
            else {
                yield `| (TypedCallParams<'${method}'> & ${onComplete.type})`;
            }
        }
        yield writer_1.DecIndent;
    }
    if (callConfig.updateMethods.length > 0) {
        yield* (0, writer_1.jsDoc)(`A factory for available 'update' calls`);
        yield `export type ${name}UpdateCalls = (typeof ${name}CallFactory)['update']`;
        yield* (0, writer_1.jsDoc)('Defines supported update methods for this smart contract');
        yield `export type ${name}UpdateCallParams =`;
        yield writer_1.IncIndent;
        for (const method of callConfig.updateMethods) {
            if (method === get_call_config_summary_1.BARE_CALL) {
                yield `| TypedCallParams<undefined>`;
            }
            else {
                yield `| TypedCallParams<'${method}'>`;
            }
        }
        yield writer_1.DecIndent;
    }
    if (callConfig.deleteMethods.length > 0) {
        yield* (0, writer_1.jsDoc)(`A factory for available 'delete' calls`);
        yield `export type ${name}DeleteCalls = (typeof ${name}CallFactory)['delete']`;
        yield* (0, writer_1.jsDoc)('Defines supported delete methods for this smart contract');
        yield `export type ${name}DeleteCallParams =`;
        yield writer_1.IncIndent;
        for (const method of callConfig.deleteMethods) {
            if (method === get_call_config_summary_1.BARE_CALL) {
                yield `| TypedCallParams<undefined>`;
            }
            else {
                yield `| TypedCallParams<'${method}'>`;
            }
        }
        yield writer_1.DecIndent;
    }
    yield* (0, writer_1.jsDoc)('Defines arguments required for the deploy method.');
    yield `export type ${name}DeployArgs = {`;
    yield writer_1.IncIndent;
    yield `deployTimeParams?: TealTemplateParams`;
    if (callConfig.createMethods.length) {
        yield* (0, writer_1.jsDoc)('A delegate which takes a create call factory and returns the create call params for this smart contract');
        yield `createCall?: (callFactory: ${name}CreateCalls) => ${name}CreateCallParams`;
    }
    if (callConfig.updateMethods.length) {
        yield* (0, writer_1.jsDoc)('A delegate which takes a update call factory and returns the update call params for this smart contract');
        yield `updateCall?: (callFactory: ${name}UpdateCalls) => ${name}UpdateCallParams`;
    }
    if (callConfig.deleteMethods.length) {
        yield* (0, writer_1.jsDoc)('A delegate which takes a delete call factory and returns the delete call params for this smart contract');
        yield `deleteCall?: (callFactory: ${name}DeleteCalls) => ${name}DeleteCallParams`;
    }
    yield writer_1.DecIndentAndCloseBlock;
    yield writer_1.NewLine;
}
exports.deployTypes = deployTypes;
//# sourceMappingURL=deploy-types.js.map