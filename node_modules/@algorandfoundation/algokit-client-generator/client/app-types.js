"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appTypes = void 0;
const writer_1 = require("../output/writer");
const algokit = __importStar(require("@algorandfoundation/algokit-utils"));
const get_equivalent_type_1 = require("./helpers/get-equivalent-type");
const sanitization_1 = require("../util/sanitization");
function* appTypes(ctx) {
    var _a, _b, _c, _d;
    const { app, methodSignatureToUniqueName, name } = ctx;
    yield* (0, writer_1.jsDoc)(`Defines the types of available calls and state of the ${name} smart contract.`);
    yield `export type ${name} = {`;
    yield writer_1.IncIndent;
    yield* (0, writer_1.jsDoc)('Maps method signatures / names to their argument and return types.');
    yield 'methods:';
    yield writer_1.IncIndent;
    for (const method of app.contract.methods) {
        const methodSig = algokit.getABIMethodSignature(method);
        const uniqueName = methodSignatureToUniqueName[methodSig];
        yield `& Record<'${methodSig}'${methodSig !== uniqueName ? ` | '${uniqueName}'` : ''}, {`;
        yield writer_1.IncIndent;
        yield `argsObj: {`;
        yield writer_1.IncIndent;
        const argsMeta = method.args.map((arg) => {
            var _a, _b, _c;
            return ({
                ...arg,
                hasDefault: (_c = (_b = (_a = app.hints) === null || _a === void 0 ? void 0 : _a[methodSig]) === null || _b === void 0 ? void 0 : _b.default_arguments) === null || _c === void 0 ? void 0 : _c[arg.name],
                tsType: (0, get_equivalent_type_1.getEquivalentType)(arg.type, 'input'),
            });
        });
        for (const arg of argsMeta) {
            if (arg.desc)
                yield* (0, writer_1.jsDoc)(arg.desc);
            yield `${(0, sanitization_1.makeSafePropertyIdentifier)(arg.name)}${arg.hasDefault ? '?' : ''}: ${arg.tsType}`;
        }
        yield writer_1.DecIndentAndCloseBlock;
        yield* (0, writer_1.inline)(`argsTuple: [`, argsMeta
            .map((arg) => `${(0, sanitization_1.makeSafeVariableIdentifier)(arg.name)}: ${(0, get_equivalent_type_1.getEquivalentType)(arg.type, 'input')}${arg.hasDefault ? ' | undefined' : ''}`)
            .join(', '), ']');
        const outputStruct = (_c = (_b = (_a = ctx.app.hints) === null || _a === void 0 ? void 0 : _a[methodSig]) === null || _b === void 0 ? void 0 : _b.structs) === null || _c === void 0 ? void 0 : _c.output;
        if (method.returns.desc)
            yield* (0, writer_1.jsDoc)(method.returns.desc);
        if (outputStruct) {
            yield `returns: ${(0, sanitization_1.makeSafeTypeIdentifier)(outputStruct.name)}`;
        }
        else {
            yield `returns: ${(0, get_equivalent_type_1.getEquivalentType)((_d = method.returns.type) !== null && _d !== void 0 ? _d : 'void', 'output')}`;
        }
        yield writer_1.DecIndent;
        yield '}>';
    }
    yield writer_1.DecIndent;
    yield* appState(ctx);
    yield writer_1.DecIndentAndCloseBlock;
    yield* (0, writer_1.jsDoc)('Defines the possible abi call signatures');
    yield `export type ${name}Sig = keyof ${name}['methods']`;
    yield* (0, writer_1.jsDoc)('Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a' +
        ' bare call is made');
    yield `export type TypedCallParams<TSignature extends ${name}Sig | undefined> = {`;
    yield writer_1.IncIndent;
    yield 'method: TSignature';
    yield 'methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>';
    yield writer_1.DecIndent;
    yield '} & AppClientCallCoreParams & CoreAppCallArgs';
    yield* (0, writer_1.jsDoc)('Defines the arguments required for a bare call');
    yield `export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>`;
    yield* structs(ctx);
    yield* (0, writer_1.jsDoc)(`Maps a method signature from the ${name} smart contract to the method's arguments in either tuple of struct form`);
    yield `export type MethodArgs<TSignature extends ${name}Sig> = ${name}['methods'][TSignature]['argsObj' | 'argsTuple']`;
    yield* (0, writer_1.jsDoc)(`Maps a method signature from the ${name} smart contract to the method's return type`);
    yield `export type MethodReturn<TSignature extends ${name}Sig> = ${name}['methods'][TSignature]['returns']`;
    yield writer_1.NewLine;
}
exports.appTypes = appTypes;
function* structs({ app }) {
    if (app.hints === undefined)
        return;
    for (const methodHint of Object.values(app.hints)) {
        if (methodHint.structs === undefined)
            continue;
        for (const struct of Object.values(methodHint.structs)) {
            yield* (0, writer_1.jsDoc)(`Represents a ${struct.name} result as a struct`);
            yield `export type ${(0, sanitization_1.makeSafeTypeIdentifier)(struct.name)} = {`;
            yield writer_1.IncIndent;
            for (const [key, type] of struct.elements) {
                yield `${(0, sanitization_1.makeSafePropertyIdentifier)(key)}: ${(0, get_equivalent_type_1.getEquivalentType)(type, 'output')}`;
            }
            yield writer_1.DecIndentAndCloseBlock;
            yield* (0, writer_1.jsDoc)(`Converts the tuple representation of a ${struct.name} to the struct representation`);
            yield* (0, writer_1.inline)(`export function ${(0, sanitization_1.makeSafeTypeIdentifier)(struct.name)}(`, `[${struct.elements.map(([key]) => (0, sanitization_1.makeSafeVariableIdentifier)(key)).join(', ')}]: `, `[${struct.elements.map(([_, type]) => (0, get_equivalent_type_1.getEquivalentType)(type, 'output')).join(', ')}] ) {`);
            yield writer_1.IncIndent;
            yield `return {`;
            yield writer_1.IncIndent;
            for (const [key] of struct.elements) {
                const prop = (0, sanitization_1.makeSafePropertyIdentifier)(key);
                const param = (0, sanitization_1.makeSafeVariableIdentifier)(key);
                yield `${prop}${prop !== param ? `: ${param}` : ''},`;
            }
            yield writer_1.DecIndentAndCloseBlock;
            yield writer_1.DecIndentAndCloseBlock;
        }
    }
}
function* appState({ app }) {
    var _a, _b;
    const hasLocal = ((_a = app.schema.local) === null || _a === void 0 ? void 0 : _a.declared) && Object.keys(app.schema.local.declared).length;
    const hasGlobal = ((_b = app.schema.global) === null || _b === void 0 ? void 0 : _b.declared) && Object.keys(app.schema.global.declared).length;
    if (hasLocal || hasGlobal) {
        yield* (0, writer_1.jsDoc)('Defines the shape of the global and local state of the application.');
        yield 'state: {';
        yield writer_1.IncIndent;
        if (hasGlobal) {
            yield 'global: {';
            yield writer_1.IncIndent;
            for (const prop of Object.values(app.schema.global.declared)) {
                if (prop.descr) {
                    yield* (0, writer_1.jsDoc)(prop.descr);
                }
                yield `'${prop.key}'?: ${prop.type === 'uint64' ? 'IntegerState' : 'BinaryState'}`;
            }
            yield writer_1.DecIndentAndCloseBlock;
        }
        if (hasLocal) {
            yield 'local: {';
            yield writer_1.IncIndent;
            for (const prop of Object.values(app.schema.local.declared)) {
                if (prop.descr) {
                    yield* (0, writer_1.jsDoc)(prop.descr);
                }
                yield `'${prop.key}'?: ${prop.type === 'uint64' ? 'IntegerState' : 'BinaryState'}`;
            }
            yield writer_1.DecIndentAndCloseBlock;
        }
        yield writer_1.DecIndentAndCloseBlock;
    }
}
//# sourceMappingURL=app-types.js.map