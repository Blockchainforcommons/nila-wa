"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.callComposerType = void 0;
const writer_1 = require("../output/writer");
const algokit = __importStar(require("@algorandfoundation/algokit-utils"));
const sanitization_1 = require("../util/sanitization");
const get_call_config_summary_1 = require("./helpers/get-call-config-summary");
const deploy_types_1 = require("./deploy-types");
function* callComposerType(ctx) {
    const { name, callConfig, app } = ctx;
    yield `export type ${name}Composer<TReturns extends [...any[]] = []> = {`;
    yield writer_1.IncIndent;
    yield* callComposerTypeNoops(ctx);
    yield* callComposerOperationMethodType(ctx, `Updates an existing instance of the ${app.contract.name} smart contract`, callConfig.updateMethods, 'update', true);
    yield* callComposerOperationMethodType(ctx, `Deletes an existing instance of the ${app.contract.name} smart contract`, callConfig.deleteMethods, 'delete');
    yield* callComposerOperationMethodType(ctx, `Opts the user into an existing instance of the ${app.contract.name} smart contract`, callConfig.optInMethods, 'optIn');
    yield* callComposerOperationMethodType(ctx, `Makes a close out call to an existing instance of the ${app.contract.name} smart contract`, callConfig.closeOutMethods, 'closeOut');
    yield* callComposerTypeClearState(ctx);
    yield* (0, writer_1.jsDoc)({
        description: 'Adds a transaction to the composer',
        params: {
            txn: 'One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)',
            defaultSender: 'The default sender to be used to obtain a signer where the object provided to the transaction parameter does not' +
                ' include a signer.',
        },
    });
    yield `addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): ${name}Composer<TReturns>`;
    yield* (0, writer_1.jsDoc)({
        description: 'Returns the underlying AtomicTransactionComposer instance',
    });
    yield `atc(): Promise<AtomicTransactionComposer>`;
    yield* (0, writer_1.jsDoc)({
        description: 'Executes the transaction group and returns an array of results',
    });
    yield `execute(): Promise<${name}ComposerResults<TReturns>>`;
    yield writer_1.DecIndentAndCloseBlock;
    yield `export type ${name}ComposerResults<TReturns extends [...any[]]> = {`;
    yield writer_1.IncIndent;
    yield `returns: TReturns`;
    yield `groupId: string`;
    yield `txIds: string[]`;
    yield `transactions: Transaction[]`;
    yield writer_1.DecIndentAndCloseBlock;
}
exports.callComposerType = callComposerType;
function* callComposerTypeClearState({ app, name }) {
    yield* (0, writer_1.jsDoc)({
        description: `Makes a clear_state call to an existing instance of the ${app.contract.name} smart contract.`,
        params: {
            args: `The arguments for the bare call`,
        },
        returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,
    });
    yield `clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): ${name}Composer<[...TReturns, undefined]>`;
    yield writer_1.NewLine;
}
function* callComposerTypeNoops({ app, name, callConfig, methodSignatureToUniqueName }) {
    for (const method of app.contract.methods) {
        const methodSignature = algokit.getABIMethodSignature(method);
        const methodName = (0, sanitization_1.makeSafeMethodIdentifier)(methodSignatureToUniqueName[methodSignature]);
        // Skip methods which don't support a no_op call config
        if (!callConfig.callMethods.includes(methodSignature))
            continue;
        yield* (0, writer_1.jsDoc)({
            description: `Calls the ${algokit.getABIMethodSignature(method)} ABI method.`,
            abiDescription: method.desc,
            params: {
                args: `The arguments for the contract call`,
                params: `Any additional parameters for the call`,
            },
            returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,
        });
        yield `${methodName}(args: MethodArgs<'${methodSignature}'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ${name}Composer<[...TReturns, MethodReturn<'${methodSignature}'>]>`;
        yield writer_1.NewLine;
    }
}
function* callComposerOperationMethodType({ app, methodSignatureToUniqueName, name }, description, methods, verb, includeCompilation) {
    if (methods.length) {
        yield* (0, writer_1.jsDoc)(`Gets available ${verb} methods`);
        yield `readonly ${verb}: {`;
        yield writer_1.IncIndent;
        for (const methodSig of methods) {
            const onComplete = verb === 'create' ? (0, deploy_types_1.getCreateOnCompleteOptions)(methodSig, app) : undefined;
            if (methodSig === get_call_config_summary_1.BARE_CALL) {
                yield* (0, writer_1.jsDoc)({
                    description: `${description} using a bare call.`,
                    params: {
                        args: `The arguments for the bare call`,
                    },
                    returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,
                });
                yield `bare(args${(onComplete === null || onComplete === void 0 ? void 0 : onComplete.isOptional) !== false ? '?' : ''}: BareCallArgs & AppClientCallCoreParams ${includeCompilation ? '& AppClientCompilationParams ' : ''}& CoreAppCallArgs${(onComplete === null || onComplete === void 0 ? void 0 : onComplete.type) ? ` & ${onComplete.type}` : ''}): ${name}Composer<[...TReturns, undefined]>`;
            }
            else {
                const uniqueName = methodSignatureToUniqueName[methodSig];
                yield* (0, writer_1.jsDoc)({
                    description: `${description} using the ${methodSig} ABI method.`,
                    params: {
                        args: `The arguments for the smart contract call`,
                        params: `Any additional parameters for the call`,
                    },
                    returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,
                });
                yield `${(0, sanitization_1.makeSafeMethodIdentifier)(uniqueName)}(args: MethodArgs<'${methodSig}'>, params${(onComplete === null || onComplete === void 0 ? void 0 : onComplete.isOptional) !== false ? '?' : ''}: AppClientCallCoreParams${includeCompilation ? ' & AppClientCompilationParams' : ''}${(onComplete === null || onComplete === void 0 ? void 0 : onComplete.type) ? ` & ${onComplete.type}` : ''}): ${name}Composer<[...TReturns, MethodReturn<'${methodSig}'>]>`;
            }
        }
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.NewLine;
    }
}
//# sourceMappingURL=call-composer-types.js.map