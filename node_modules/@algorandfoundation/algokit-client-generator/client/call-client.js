"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.callClient = void 0;
const algokit = __importStar(require("@algorandfoundation/algokit-utils"));
const writer_1 = require("../output/writer");
const sanitization_1 = require("../util/sanitization");
const get_call_config_summary_1 = require("./helpers/get-call-config-summary");
const deploy_types_1 = require("./deploy-types");
const call_composer_1 = require("./call-composer");
function* callClient(ctx) {
    const { app, name } = ctx;
    yield* (0, writer_1.jsDoc)(`A client to make calls to the ${app.contract.name} smart contract`);
    yield `export class ${(0, sanitization_1.makeSafeTypeIdentifier)(app.contract.name)}Client {`;
    yield writer_1.IncIndent;
    yield* (0, writer_1.jsDoc)(`The underlying \`ApplicationClient\` for when you want to have more flexibility`);
    yield 'public readonly appClient: ApplicationClient';
    yield writer_1.NewLine;
    yield `private readonly sender: SendTransactionFrom | undefined`;
    yield writer_1.NewLine;
    yield* (0, writer_1.jsDoc)({
        description: `Creates a new instance of \`${(0, sanitization_1.makeSafeTypeIdentifier)(app.contract.name)}Client\``,
        params: {
            appDetails: 'appDetails The details to identify the app to deploy',
            algod: 'An algod client instance',
        },
    });
    yield `constructor(appDetails: AppDetails, private algod: Algodv2) {`;
    yield writer_1.IncIndent;
    yield `this.sender = appDetails.sender`;
    yield 'this.appClient = algokit.getAppClient({';
    yield* (0, writer_1.indent)('...appDetails,', 'app: APP_SPEC');
    yield '}, algod)';
    yield writer_1.DecIndent;
    yield '}';
    yield writer_1.NewLine;
    yield* (0, writer_1.jsDoc)({
        description: 'Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type',
        params: {
            result: 'The AppCallTransactionResult to be mapped',
            returnValueFormatter: 'An optional delegate to format the return value if required',
        },
        returns: 'The smart contract response with an updated return value',
    });
    yield* (0, writer_1.inline)(`protected mapReturnValue<TReturn>`, `(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): `, `AppCallTransactionResultOfType<TReturn> {`);
    yield writer_1.IncIndent;
    yield `if(result.return?.decodeError) {`;
    yield* (0, writer_1.indent)(`throw result.return.decodeError`);
    yield `}`;
    yield `const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined`;
    yield writer_1.IncIndent;
    yield `? returnValueFormatter(result.return.returnValue)`;
    yield `: result.return?.returnValue as TReturn | undefined`;
    yield `return { ...result, return: returnValue }`;
    yield writer_1.DecIndent;
    yield writer_1.DecIndentAndCloseBlock;
    yield writer_1.NewLine;
    yield* (0, writer_1.jsDoc)({
        description: 'Calls the ABI method with the matching signature using an onCompletion code of NO_OP',
        params: {
            typedCallParams: 'An object containing the method signature, args, and any other relevant parameters',
            returnValueFormatter: 'An optional delegate which when provided will be used to map non-undefined return values to the target type',
        },
        returns: 'The result of the smart contract call',
    });
    yield `public async call<TSignature extends keyof ${name}['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {`;
    yield writer_1.IncIndent;
    yield `return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)`;
    yield writer_1.DecIndentAndCloseBlock;
    yield writer_1.NewLine;
    yield* opMethods(ctx);
    yield* clearState(ctx);
    yield* noopMethods(ctx);
    yield* getStateMethods(ctx);
    yield* (0, call_composer_1.composeMethod)(ctx);
    yield writer_1.DecIndentAndCloseBlock;
}
exports.callClient = callClient;
function* opMethods(ctx) {
    const { app, callConfig, name } = ctx;
    yield* (0, writer_1.jsDoc)({
        description: `Idempotently deploys the ${app.contract.name} smart contract.`,
        params: {
            params: 'The arguments for the contract calls and any additional parameters for the call',
        },
        returns: 'The deployment result',
    });
    yield `public deploy(params: ${name}DeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {`;
    yield writer_1.IncIndent;
    if (callConfig.createMethods.length)
        yield `const createArgs = params.createCall?.(${name}CallFactory.create)`;
    if (callConfig.updateMethods.length)
        yield `const updateArgs = params.updateCall?.(${name}CallFactory.update)`;
    if (callConfig.deleteMethods.length)
        yield `const deleteArgs = params.deleteCall?.(${name}CallFactory.delete)`;
    yield `return this.appClient.deploy({`;
    yield writer_1.IncIndent;
    yield `...params,`;
    if (callConfig.updateMethods.length)
        yield 'updateArgs,';
    if (callConfig.deleteMethods.length)
        yield 'deleteArgs,';
    if (callConfig.createMethods.length) {
        yield 'createArgs,';
        yield `createOnCompleteAction: createArgs?.onCompleteAction,`;
    }
    yield writer_1.DecIndent;
    yield `})`;
    yield writer_1.DecIndentAndCloseBlock;
    yield writer_1.NewLine;
    yield* operationMethod(ctx, `Creates a new instance of the ${app.contract.name} smart contract`, callConfig.createMethods, 'create', true);
    yield* operationMethod(ctx, `Updates an existing instance of the ${app.contract.name} smart contract`, callConfig.updateMethods, 'update', true);
    yield* operationMethod(ctx, `Deletes an existing instance of the ${app.contract.name} smart contract`, callConfig.deleteMethods, 'delete');
    yield* operationMethod(ctx, `Opts the user into an existing instance of the ${app.contract.name} smart contract`, callConfig.optInMethods, 'optIn');
    yield* operationMethod(ctx, `Makes a close out call to an existing instance of the ${app.contract.name} smart contract`, callConfig.closeOutMethods, 'closeOut');
}
function* operationMethod({ app, methodSignatureToUniqueName, name }, description, methods, verb, includeCompilation) {
    var _a;
    if (methods.length) {
        yield* (0, writer_1.jsDoc)(`Gets available ${verb} methods`);
        yield `public get ${verb}() {`;
        yield writer_1.IncIndent;
        yield `const $this = this`;
        yield `return {`;
        yield writer_1.IncIndent;
        for (const methodSig of methods) {
            const onComplete = verb === 'create' ? (0, deploy_types_1.getCreateOnCompleteOptions)(methodSig, app) : undefined;
            if (methodSig === get_call_config_summary_1.BARE_CALL) {
                yield* (0, writer_1.jsDoc)({
                    description: `${description} using a bare call.`,
                    params: {
                        args: `The arguments for the bare call`,
                    },
                    returns: `The ${verb} result`,
                });
                yield `bare(args: BareCallArgs & AppClientCallCoreParams ${includeCompilation ? '& AppClientCompilationParams ' : ''}& CoreAppCallArgs${(onComplete === null || onComplete === void 0 ? void 0 : onComplete.type) ? ` & ${onComplete.type}` : ''}${(onComplete === null || onComplete === void 0 ? void 0 : onComplete.isOptional) !== false ? ' = {}' : ''}): Promise<AppCallTransactionResultOfType<undefined>> {`;
                yield* (0, writer_1.indent)(`return $this.appClient.${verb}(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>`);
                yield '},';
            }
            else {
                const uniqueName = methodSignatureToUniqueName[methodSig];
                const method = app.contract.methods.find((m) => algokit.getABIMethodSignature(m) === methodSig);
                yield* (0, writer_1.jsDoc)({
                    description: `${description} using the ${methodSig} ABI method.`,
                    params: {
                        args: `The arguments for the smart contract call`,
                        params: `Any additional parameters for the call`,
                    },
                    returns: `The ${verb} result${((_a = method === null || method === void 0 ? void 0 : method.returns) === null || _a === void 0 ? void 0 : _a.desc) ? `: ${method.returns.desc}` : ''}`,
                });
                yield `async ${(0, sanitization_1.makeSafeMethodIdentifier)(uniqueName)}(args: MethodArgs<'${methodSig}'>, params: AppClientCallCoreParams${includeCompilation ? ' & AppClientCompilationParams' : ''}${(onComplete === null || onComplete === void 0 ? void 0 : onComplete.type) ? ` & ${onComplete.type}` : ''}${(onComplete === null || onComplete === void 0 ? void 0 : onComplete.isOptional) !== false ? ' = {}' : ''}): Promise<AppCallTransactionResultOfType<MethodReturn<'${methodSig}'>>> {`;
                yield* (0, writer_1.indent)(`return $this.mapReturnValue(await $this.appClient.${verb}(${name}CallFactory.${verb}.${(0, sanitization_1.makeSafeMethodIdentifier)(uniqueName)}(args, params)))`);
                yield '},';
            }
        }
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.NewLine;
    }
}
function* clearState({ app }) {
    yield* (0, writer_1.jsDoc)({
        description: `Makes a clear_state call to an existing instance of the ${app.contract.name} smart contract.`,
        params: {
            args: `The arguments for the bare call`,
        },
        returns: `The clear_state result`,
    });
    yield `public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {`;
    yield writer_1.IncIndent;
    yield `return this.appClient.clearState(args)`;
    yield writer_1.DecIndentAndCloseBlock;
    yield writer_1.NewLine;
}
function* noopMethods({ app, name, callConfig, methodSignatureToUniqueName }) {
    var _a, _b, _c, _d, _e;
    for (const method of app.contract.methods) {
        const methodSignature = algokit.getABIMethodSignature(method);
        const methodName = (0, sanitization_1.makeSafeMethodIdentifier)(methodSignatureToUniqueName[methodSignature]);
        // Skip methods which don't support a no_op call config
        if (!callConfig.callMethods.includes(methodSignature))
            continue;
        yield* (0, writer_1.jsDoc)({
            description: `Calls the ${algokit.getABIMethodSignature(method)} ABI method.`,
            abiDescription: method.desc,
            params: {
                args: `The arguments for the contract call`,
                params: `Any additional parameters for the call`,
            },
            returns: `The result of the call${((_a = method === null || method === void 0 ? void 0 : method.returns) === null || _a === void 0 ? void 0 : _a.desc) ? `: ${method.returns.desc}` : ''}`,
        });
        yield `public ${methodName}(args: MethodArgs<'${methodSignature}'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {`;
        yield writer_1.IncIndent;
        const outputTypeName = (_e = (_d = (_c = (_b = app.hints) === null || _b === void 0 ? void 0 : _b[methodSignature]) === null || _c === void 0 ? void 0 : _c.structs) === null || _d === void 0 ? void 0 : _d.output) === null || _e === void 0 ? void 0 : _e.name;
        yield `return this.call(${name}CallFactory.${methodName}(args, params)${outputTypeName === undefined ? '' : `, ${(0, sanitization_1.makeSafeTypeIdentifier)(outputTypeName)}`})`;
        yield writer_1.DecIndent;
        yield '}';
        yield writer_1.NewLine;
    }
}
function* getStateMethods({ app, name }) {
    var _a, _b, _c, _d;
    const globalStateValues = ((_a = app.schema.global) === null || _a === void 0 ? void 0 : _a.declared) && Object.values((_b = app.schema.global) === null || _b === void 0 ? void 0 : _b.declared);
    const localStateValues = ((_c = app.schema.local) === null || _c === void 0 ? void 0 : _c.declared) && Object.values((_d = app.schema.local) === null || _d === void 0 ? void 0 : _d.declared);
    if ((globalStateValues === null || globalStateValues === void 0 ? void 0 : globalStateValues.length) || (localStateValues === null || localStateValues === void 0 ? void 0 : localStateValues.length)) {
        yield* (0, writer_1.jsDoc)({
            description: 'Extracts a binary state value out of an AppState dictionary',
            params: {
                state: 'The state dictionary containing the state value',
                key: 'The key of the state value',
            },
            returns: 'A BinaryState instance containing the state value, or undefined if the key was not found',
        });
        yield `private static getBinaryState(state: AppState, key: string): BinaryState | undefined {`;
        yield writer_1.IncIndent;
        yield `const value = state[key]`;
        yield `if (!value) return undefined`;
        yield `if (!('valueRaw' in value))`;
        yield* (0, writer_1.indent)(`throw new Error(\`Failed to parse state value for \${key}; received an int when expected a byte array\`)`);
        yield `return {`;
        yield writer_1.IncIndent;
        yield `asString(): string {`;
        yield* (0, writer_1.indent)(`return value.value`);
        yield `},`;
        yield `asByteArray(): Uint8Array {`;
        yield* (0, writer_1.indent)(`return value.valueRaw`);
        yield `}`;
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.NewLine;
        yield* (0, writer_1.jsDoc)({
            description: 'Extracts a integer state value out of an AppState dictionary',
            params: {
                state: 'The state dictionary containing the state value',
                key: 'The key of the state value',
            },
            returns: 'An IntegerState instance containing the state value, or undefined if the key was not found',
        });
        yield `private static getIntegerState(state: AppState, key: string): IntegerState | undefined {`;
        yield writer_1.IncIndent;
        yield `const value = state[key]`;
        yield `if (!value) return undefined`;
        yield `if ('valueRaw' in value)`;
        yield* (0, writer_1.indent)(`throw new Error(\`Failed to parse state value for \${key}; received a byte array when expected a number\`)`);
        yield `return {`;
        yield writer_1.IncIndent;
        yield `asBigInt() {`;
        yield* (0, writer_1.indent)(`return typeof value.value === 'bigint' ? value.value : BigInt(value.value)`);
        yield `},`;
        yield `asNumber(): number {`;
        yield* (0, writer_1.indent)(`return typeof value.value === 'bigint' ? Number(value.value) : value.value`);
        yield `},`;
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.NewLine;
    }
    if (globalStateValues === null || globalStateValues === void 0 ? void 0 : globalStateValues.length) {
        yield* (0, writer_1.jsDoc)(`Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value`);
        yield `public async getGlobalState(): Promise<${name}['state']['global']> {`;
        yield writer_1.IncIndent;
        yield `const state = await this.appClient.getGlobalState()`;
        yield `return {`;
        yield writer_1.IncIndent;
        for (const stateValue of globalStateValues) {
            yield `get ${stateValue.key}() {`;
            if (stateValue.type === 'uint64') {
                yield* (0, writer_1.indent)(`return ${name}Client.getIntegerState(state, '${stateValue.key}')`);
            }
            else {
                yield* (0, writer_1.indent)(`return ${name}Client.getBinaryState(state, '${stateValue.key}')`);
            }
            yield '},';
        }
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.NewLine;
    }
    if (localStateValues === null || localStateValues === void 0 ? void 0 : localStateValues.length) {
        yield* (0, writer_1.jsDoc)({
            description: `Returns the smart contract's local state wrapped in a strongly typed accessor with options to format the stored value`,
            params: {
                account: `The address of the account for which to read local state from`,
            },
        });
        yield `public async getLocalState(account: string | SendTransactionFrom): Promise<${name}['state']['local']> {`;
        yield writer_1.IncIndent;
        yield `const state = await this.appClient.getLocalState(account)`;
        yield `return {`;
        yield writer_1.IncIndent;
        for (const stateValue of localStateValues) {
            yield `get ${stateValue.key}() {`;
            if (stateValue.type === 'uint64') {
                yield* (0, writer_1.indent)(`return ${name}Client.getIntegerState(state, '${stateValue.key}')`);
            }
            else {
                yield* (0, writer_1.indent)(`return ${name}Client.getBinaryState(state, '${stateValue.key}')`);
            }
            yield '},';
        }
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.DecIndentAndCloseBlock;
        yield writer_1.NewLine;
    }
}
//# sourceMappingURL=call-client.js.map